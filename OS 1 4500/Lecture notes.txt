Lecture 1:
Sourav Purification
spurific@uccs.edu

Understand OS abstraction
Analyze system resource Management
Apply Concurrency Fundamentals
introduce systems security

OS overview:
read 1.1-1.2

computers have 2 modes
user mode
kernal mode

transitions between user/kernal
    hardware interrupt
    system call
    exception


different types of OS   
    batch processing - process job one at a time
    time sharing OS - process mulitple jobs in round robin
    real-time OS - still time-sharing, but has deadlines for certain jobs
    distributed OS - multiple computers run a single copy of OS
    embedded OS - runs on cell phones and PDA's


Kernel is the heart of OS

A monolithic kernel is a model where all OS services run in kernel mode. 
The pros of this are its faster due to the simple communication. The cons 
are that its much larger and more complex system, so one bug or error can 
crash the whole system and make maintaining/debugging very difficult

A microkernal is a model where only essential services run in kernel mode, 
like IPC, scheduling, and basic memory; the other functions run in user mode. 
The pros of this is its more stable/secure because faults are isolated. 
The cons are that it is slower and more work for IPC 

Register
Cache
RAM (Memory)
    SSD
    HDD
    FLASH
    DVD


    Hardware device events can be processed though polling interupt and DMA
    polling is checking every so often for interrupt
    interupt is like a door bell
    Dynamic access is like having an assistant to handle interrupt



Processes(programs):
    processes are programs running by the cpu. processes are init from programs and are 
    given space and time sharing by cpu. 

    termination
        normal exit(voluntary)
        Error Exit(voluntary)
        Killed by another process(involuntary)


how many states can a process have 
    TASk_RUNNING
    TASK_INTERRUPTSBLE
    EXIT_ZOMBIE
    EXIT_DEAD


Project 1 is making a kernal app with c, should be light, but dont procrastinate it


processs have 3 states
    ready
    running
    blocked

pcb 
    process control block
    zombie process
        process finishes execution(called exit)


multicore/threaded cpu, parral processing = hardware

pc scheduling
    First come first serve
    round robin(n time increments)
    predetermined
    non predetermined

CPU scheduling advanced:
    FIFO, RR, and Preditermed dont work for real time systems
    we need more complex multilevel queue
        we want to minimize respnse time and turnaournd time without knowing burst time
        multilevel queue can assign priority to processs and pick high priority processes.

        to avoid starvation we assign an allotment or an ammount of time
        a process can remain at the priority level it has

        rule 1 highest priority first
        rule 2 if multiple have same priority use RR
        rule 3 when a job enters the system it has highest priority
        rule 4 once a job uses up its allotment at a given level its priority is reduced
        rule 5 after some time period, move all jobs in the system to the topmost queue


    CFS - completly fair scheduling
        proportional shar or fair share
            instead of optimzing turnaround or response time a schedulare might 
            garuntee that each process gets a percentage of CPU time
        use randomness in process sharing
            each process will run for R amount of time
            
        non-fixed timeslice
            CFS assignes a proportional timeslice per process

        priority is enabled with niceness values

        efficient data structure - use redblack trees for insertion deletion

        CFS picks the lowest Vrun time to run next
            VRUN time is the time a process has run already

            Sched_latency
            A typical value is 48 (ms)
            Processâ€™s timeslice = sched_latency / (the number of processes)



    A parent process creates a process

    inter process communication(IPC)
        message sharing
        kernal hosted messaging
        shared memory


    race conditions - multiple processes racing to use a space potentially
        avoid with
            mutual exclusion
                make sure if one process is using a shared file others will be excluded
                to provide mutual exclusion
                    no two processes in the critial region simultaniously
                    no assumptions made about speeds or number of cpu
                    no process running outside its critical region may block another process
                    no process must wait forever to enter its critical region
            critical regions
                part of system where shared files are

            disabling interrupts - can be useful in certain situations, not helpful with multiple cpu
            lock variables - shared lock 0 or 1
            busy waiting - when process checks variable untill a value appears
                a lock using this method is called a spin lock
